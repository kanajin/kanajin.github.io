[{"content":" 当前博客使用PaperMod主题，使用github托管发布。\n源文件仓库位于https://github.com/kanajin/hugo-blog-source\n初期学习时提交过多无用commit，望海涵\nhugo quick start：https://gohugo.io/getting-started/quick-start/\n1. 安装Hugo 可以直接前往Hugo官网下载查看说明\n此外各操作系统均可使用包管理器安装\nWindows：scoop scoop bucket add extras scoop install hugo Linxu与macOS不再赘述\n安装成功后使用命令hugo version确认安装情况\n2. 建站 使用命令hugo new site \u0026lt;name\u0026gt;来新建一个博客站点，可以在命令中指定博客配置文件的格式，例如\nhugo new site myname.github.io # 配置文件为hugo.toml hugo new site myname.github.io --format yaml # 配置文件为hugo.yaml，推荐，yaml格式更加易读 这个命令会在终端的当前目录下新建一个名为myname.github.io的目录，并部署好Hugo所需的资源，目录结构大致如下所示：\n$ tree . ├── archetypes │ └── default.md # 文章头部模板，新建博文时会使用这里的文章头部配置 ├── assets ├── content # 用于存放博文 ├── data ├── config.yaml # 配置文件，新版中可能叫做hugo.yaml，本文以config为准 ├── i18n ├── layouts # 存放模板文件，指导Hugo如何将content目录中的markdown渲染成HTML ├── static # 用于存放静态文件，如图片、CSS、JavaScript 文件等，建议使用git lfs管理 └── themes # 用于存放主题 9 directories, 2 files 这里要注意站点的名称必须是\u0026lt;自定义英文\u0026gt;.github.io的格式，才能被正确托管\n3. 指定主题 Hugo的站点必须安装主题才能够使用，因此需要先挑选一个合适的主题\n主题下载站：https://themes.gohugo.io/，或是中文网站：https://www.gohugo.org/theme/。选择好心仪的主题后，根据网站中的引导可以进入主题的GitHub仓库\nHugo站点的主题需要将主题代码目录放进 /themes/目录中，并在 config.yaml 中指定主题，格式为theme: [\u0026lt;theme_name\u0026gt;]\n主题的安装方式在主题仓库中均有文档，自行查阅\n个人建议的维护主题的方式为： 将主题仓库fork一遍，并在fork仓库中做自己的修改，然后博客站安装自己仓库的主题\n4. 配置文件 config.yaml的官方文档\n大部分配置是通用的，少数配置参数需要参考主题文档调整。下面是我的部分配置和一些说明\n# If your site is in \u0026#39;https\u0026#39;, then make sure your base url isn\u0026#39;t written using \u0026#39;http\u0026#39; otherwise your sitemap would # contain http (as opposeed to https) URLs. This would affect Google indexing of your URLs. baseURL: \u0026#34;https://kanajin.github.io\u0026#34; # 网站域名 title: \u0026#34;Alea jacta est!\u0026#34; # 网站标题 paginate: 5 # 每页显示的内容项数 theme: [PaperMod] # 主题 enableInlineShortcodes: true # 启用内联短代码 enableRobotsTXT: true # 生成robot.txt用于指导爬虫 buildDrafts: false # 若文章被标记为“草稿”，则不会发布在网站上 buildFuture: false # 若文章的发布日期设置在未来，则不会发布在网站上 enableEmoji: true pygmentsUseClasses: true # 可以通过CSS设置代码样式 mainsections: [\u0026#34;posts\u0026#34;] # 生成主页时以/posts/目录下的项目为主 defaultContentLanguage: \u0026#34;zh\u0026#34; # 设置默认语言 languages: # 语言配置 zh: languageName: \u0026#34;简体中文\u0026#34; weight: 1 taxonomies: # 定义分类法，在文章头部可以指定文章的相关分类，Hugo会识别并自动帮你分类 category: categories tag: tags series: series menu: # 菜单项配置 main: - name: 归档 url: archives weight: 1 # 权重，越低越靠前 - name: 搜索 url: search/ # 主题配置 weight: 2 - name: 分类 url: categories # 分类法定义的分类 weight: 3 - name: 标签 url: tags # 分类法定义的分类 weight: 4 outputs: # 指示构建网页时应该输出哪些文件 home: - HTML # 网页基本构成 - RSS # 用于订阅 - JSON # 用于爬虫 params: # 为主题配置，需参考主题文档 env: production author: 铃兰怜雪 ... 5. 构建网站 在项目根目录下执行 hugo 命令可以在本地启动服务器，以下是一些常用命令与解释\nhugo server # 最常用的命令，采用hugo默认配置构建页面，默认监听 localhost:1313 hugo server -D # 即使被标记为“草稿”的文章也会被发布 hugo server --bind 0.0.0.0 # 监听0.0.0.0，方便在局域网其他设备上启动服务 hugo # 在根目录生成public/目录，将构建的网站内容放进其中 hugo --cleanDestinationDir # 会先清除public/目录，再重新构建，即清除缓存 # 后两个命令不会启动服务 6. 撰写博客 使用hugo new \u0026lt;path/to/article_name.md\u0026gt;可以在/content/path/to/目录生成一个.md文件，用于撰写你的博客\n.md文件会自带类似下面的内容：\n--- title: \u0026#34;some title\u0026#34; date: a date draft: true tags: [\u0026#34;tag1\u0026#34;, \u0026#34;tag2\u0026#34;] categories: [\u0026#34;categories1\u0026#34;] description: \u0026#34;some description\u0026#34; --- 具体内容可以在/archetypes/default.md中设定，这个也是上文提到的文章头，请保留。更多设置参考官方文档\n使用markdown语法来撰写博文，hugo会帮助你渲染成HTML并发布在站点上。简单的markdown语法规则可以阅读菜鸟教程\n7. 由Github自动生成网站并发布 通过Github workflow，可以自动将写好的markdown文件编译成静态网页并发布到Github page，让自己只需要专注写内容即可，可谓一劳永逸\n申请Token 由于每次编译网页并托管给Github page都需要验证身份，因此需要先申请一个token，并自动把token传进去做验证\n申请token的路径是：github - Settings - 最下面的Developer Settings - Personal access tokens - Tokens(classic)\n注意同级还有另一个选项：Fine-grained tokens，并不能用于workflow，不要申请错了\n申请会要求你输入一个名字，这里我们假设名字是HUGO_KEY，成功后会给你一个TOKENID，复制并保存好，以后看不到了\n写workflow文件 在项目根目录进行操作\n$ myname.github.io \u0026gt; mkdir -p .github/workflows/ cd .github/workflows touch main.yml 在创建的main.yml中输入如下内容\nname: Build and Deploy Hugo Site on: push: branches: - master jobs: build-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: \u0026#39;recursive\u0026#39; lfs: true - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; - name: Build Hugo Site run: hugo --minify - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.HUGO_KEY }} # 这里把HUGO_KEY换成你的TOKEN名字 publish_dir: ./public 完成这些之后，你可以写一篇文章，然后尝试发布\n直接push仓库，如果一切顺利的话你的仓库会多一个名为gh-pages的分支，然后在项目的设置里找到Pages，在Build and deployment里面将Branch设置为gh-pages，等一段时间应该就能发布自己的博客了\n博客的地址就是https://myname.github.io\n","permalink":"https://kanajin.github.io/posts/life/build-blog/","summary":"当前博客使用PaperMod主题，使用github托管发布。\n源文件仓库位于https://github.com/kanajin/hugo-blog-source\n初期学习时提交过多无用commit，望海涵\nhugo quick start：https://gohugo.io/getting-started/quick-start/\n1. 安装Hugo 可以直接前往Hugo官网下载查看说明\n此外各操作系统均可使用包管理器安装\nWindows：scoop scoop bucket add extras scoop install hugo Linxu与macOS不再赘述\n安装成功后使用命令hugo version确认安装情况\n2. 建站 使用命令hugo new site \u0026lt;name\u0026gt;来新建一个博客站点，可以在命令中指定博客配置文件的格式，例如\nhugo new site myname.github.io # 配置文件为hugo.toml hugo new site myname.github.io --format yaml # 配置文件为hugo.yaml，推荐，yaml格式更加易读 这个命令会在终端的当前目录下新建一个名为myname.github.io的目录，并部署好Hugo所需的资源，目录结构大致如下所示：\n$ tree . ├── archetypes │ └── default.md # 文章头部模板，新建博文时会使用这里的文章头部配置 ├── assets ├── content # 用于存放博文 ├── data ├── config.yaml # 配置文件，新版中可能叫做hugo.yaml，本文以config为准 ├── i18n ├── layouts # 存放模板文件，指导Hugo如何将content目录中的markdown渲染成HTML ├── static # 用于存放静态文件，如图片、CSS、JavaScript 文件等，建议使用git lfs管理 └── themes # 用于存放主题 9 directories, 2 files 这里要注意站点的名称必须是\u0026lt;自定义英文\u0026gt;.","title":"使用Hugo搭建博客"},{"content":"冒泡排序 重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来，因小元素会经由交换慢慢“浮”到数列的顶端而得名\n代码 func bubbleSort[T constraints.Ordered](arr []T) { for i := 0; i \u0026lt; len(arr); i++ { for j := i; j \u0026lt; len(arr); j++ { if arr[i] \u0026gt; arr[j] { arr[i], arr[j] = arr[j], arr[i] //swap } } } } 插入排序 从第二个元素(index=1)开始，不断向前“插队”到第一个比他小的元素之后\n代码 func insertionSort[T constraints.Ordered](arr []T) { for i := 1; i \u0026lt; len(arr); i++ { j := i - 1 key := arr[i] for ; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key; j-- { arr[j+1] = arr[j] } arr[j+1] = key } } 选择排序 反复遍历数组，每次选出最小的元素移动至合适的位置\n代码 func selectionSort[T constraints.Ordered](arr []T) { for i := 0; i \u0026lt; len(arr)-1; i++ { min := i for j := i + 1; j \u0026lt; len(arr); j++ { if arr[j] \u0026lt; arr[i] { min = j } } if min != i { swap(arr, i, min) } } } 快速排序 选出一个基准值 将数组调整为两部分，左边元素比基准值小，右边元素比基准值大 将两部分数组递归地执行1、2步骤，最后完成排序 代码 func quickSort[T constraints.Ordered](arr []T) { //算法接口 if len(arr) \u0026lt; 2 { return } _quick(arr, 0, len(arr)) } func _quick[T constraints.Ordered](arr []T, start, end int) { //递归段 if start \u0026gt;= end { return } idx := partition(arr, start, end) _quick(arr, start, idx-1) //分成左右两部分 _quick(arr, idx, end) } func partition[T constraints.Ordered](arr []T, start, end int) int { //排序段，以段落的第一个元素arr[start]为基准 idx := start + 1 for i := idx; i \u0026lt; end; i++ { if arr[i] \u0026lt; arr[start] { arr[i], arr[idx] = arr[idx], arr[i] //将比基准值小的数放到数组左边 idx++ } } arr[start], arr[idx-1] = arr[idx-1], arr[start] //将基准值放在中间 return idx //返回基准值的下标 } 堆排序 先将数组构建为大根堆 将堆顶元素与末位元素对调，即将当前最大元素放到正确的位置，将调整后的大元素移出堆，不参与调整 重新将调整后的堆转化为大根堆 重复操作，直到所有元素都被移出堆 代码 func heapSort[T constraints.Ordered](arr []T) { arrLen := len(arr) buildMaxHeap(arr, arrLen) for i := arrLen - 1; i \u0026gt;= 0; i-- { //不断将堆顶元素交换到“末位” arr[0], arr[i] = arr[i], arr[0] arrLen-- //将末位元素移出堆 heapify(arr, 0, arrLen) } } func buildMaxHeap[T constraints.Ordered](arr []T, arrLen int) { //构建堆 for i := arrLen / 2; i \u0026gt;= 0; i-- { //从最后一个非叶节点开始 heapify(arr, i, arrLen) } } func heapify[T constraints.Ordered](arr []T, idx, arrLen int) { //调整堆 l := idx*2 + 1 //左子树 r := idx*2 + 2 //右子树 largest := idx if l \u0026lt; arrLen \u0026amp;\u0026amp; arr[l] \u0026gt; arr[largest] { largest = l } if r \u0026lt; arrLen \u0026amp;\u0026amp; arr[r] \u0026gt; arr[largest] { largest = r } if largest != idx { arr[idx], arr[largest] = arr[largest], arr[idx] heapify(arr, largest, arrLen) } } ","permalink":"https://kanajin.github.io/posts/cs/algorithm/sorts/","summary":"冒泡排序 重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来，因小元素会经由交换慢慢“浮”到数列的顶端而得名\n代码 func bubbleSort[T constraints.Ordered](arr []T) { for i := 0; i \u0026lt; len(arr); i++ { for j := i; j \u0026lt; len(arr); j++ { if arr[i] \u0026gt; arr[j] { arr[i], arr[j] = arr[j], arr[i] //swap } } } } 插入排序 从第二个元素(index=1)开始，不断向前“插队”到第一个比他小的元素之后\n代码 func insertionSort[T constraints.Ordered](arr []T) { for i := 1; i \u0026lt; len(arr); i++ { j := i - 1 key := arr[i] for ; j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key; j-- { arr[j+1] = arr[j] } arr[j+1] = key } } 选择排序 反复遍历数组，每次选出最小的元素移动至合适的位置","title":"排序算法"}]